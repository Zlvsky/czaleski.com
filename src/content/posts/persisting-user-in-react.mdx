---
title: "React - Utrzymywanie sesji uÅ¼ytkownika za pomocÄ… Redux'a i Cookies"
category: 'react'
publishedAt: '13-12-2023'
isPublished: true
popular: false
image: '/img/persist-user/thumbnail.png'
excerpt: "PrzedstawiÄ™ wam mÃ³j ulubiony sposÃ³b na podtrzymywanie sesji zalogowanego uÅ¼ytkownika w Reactcie z pomocÄ… Redux Toolkit i Cookies."
---

Doing a quick research on the question "How to persist User in React" we will find many solutions. The most popular methods we can find are solutions using **localstorage**, **Cookies**, **sessionstorage** or external libraries.

Which method will be the best? Well, it depends:) I personally liked the method best, which I will describe to you in more detail shortly and demonstrate how to implement it.

## What do we want to achieve?

Let's start by writing out for ourselves what specifically we want to achieve - this will make it easier to visualize the implementation itself.

 1. After logging in, we need to store the token somewhere - in our case JWT.
 2. We also need to check if our token has expired.
 3. After re-entering the site, if the token is still valid, we should continue to be logged in.

Now let's get down to work ğŸ‘‡ 

## 1. Storing the token

The place where we will store our JWT token will be **Cookies**. For this I recommend the library [js-cookie](https://www.npmjs.com/package/js-cookie), thanks to which we can easily save, delete and receive values from cookies, in addition, we can set for how long they should be valid.

So let's assume that we make a request to log in, if it succeeds we can save our token.

```ts
import Cookies from "js-cookie";

const handleLoginRequest = async () => {
  const dataToSend = {
    email,
    password
  };
  const response = await loginService(dataToSend);
  if (response.status !== 200) return console.log("LOGIN FAILED");
  // ON LOGIN SUCCESS  
  Cookies.set("jwt", response.data.token);
};
```

If we want to set, a specific validity of days of **cookies**, we can do it like this:

```ts
// TOKEN EXPIRES 7 DAYS FROM NOW
Cookies.set("jwt", response.data.token, { expires: 7 })
```

## 2. Controlling the validity of the token.

We already have a stored token with which we can make requests. Let's now get down to controlling its validity.

The key to this will be **request**, which will return to us, for example, the data of the logged-in user.

The place to store this data will be **store** in [Redux](https://redux-toolkit.js.org/).

So let's create a **store.ts** file in the **/src/redux** folder.

```ts
import { configureStore } from "@reduxjs/toolkit";

export const store = configureStore({
  reducer: {},
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

A nastÄ™pnie w folderze **/src/redux/reducers** plik **userReducer.ts**

```ts
import { createSlice } from "@reduxjs/toolkit";
import { RootState } from "../store";

const initialState = {
  user: null,
};

export const userSlice = createSlice({
  initialState,
  name: "user",
  reducers: {
    // WYLOGOWANIE UÅ»YTKOWNIKA
    logout: () => initialState,
    // ZAPISANIE DANYCH UÅ»YTKOWNIKA
    setUser: (state, action) => {
      state.user = action.payload;
    },
  },
});

// POBRANIE DANYCH UÅ»YTKOWNIKA
export const getUser = (state: RootState) => state.user.user;
export const { logout, setUser } = userSlice.actions;
export default userSlice.reducer;
```

InteresujÄ… nas tutaj 3 rzeczy:

 - logout - Czyszczenie stanu uÅ¼ytkownika
 - setUser - Zapisanie danych uÅ¼ytkownika do state'u uÅ¼ytkownika.
 - getUser - Pobranie danych ze state'u uÅ¼ytkownika

Zaimportujmy teraz **userSlice** do naszego reduxowego **store**.

```ts
import { configureStore } from "@reduxjs/toolkit";
import userSlice from "./reducers/userSlice";

export const store = configureStore({
  reducer: {
    user: userSlice,
  },
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

Dodajmy teraz komponent **< Provider/>** z podpiÄ™tym **store**, aby umoÅ¼liwiÄ‡ dostÄ™p do danych Reduxa w naszej aplikacji.

Koniecznym jest, aby **< Provider/>** znalazÅ‚ siÄ™ w komponencie najwyÅ¼szego poziomu (przewaÅ¼nie bÄ™dzie to plik **main** albo **index**).

```ts
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import store from './redux/store'
import { Provider } from 'react-redux'
import { Router } from './router/Router'

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <Provider store={store}>
        <Router />
    </Provider>
  </React.StrictMode>
);

```

Potrzebujemy jeszcze funkcji, ktÃ³ra obsÅ‚uÅ¼y wyczyszczenie state'u oraz usuniÄ™cie ciasteczka z JWT. 

```ts
import { Dispatch } from "@reduxjs/toolkit";
import { logout } from "../../redux/reducers/userSlice";
import Cookies from "js-cookie";

export function logoutUser(dispatch: Dispatch) {
  Cookies.remove("jwt");
  dispatch(logout());
  window.location.href = "/login";
}
```
A takÅ¼e funkcji, ktÃ³ra wyÅ›le request do API z zapisanym tokenem JWT i w przypadku powodzenia zapisze dane do **reduxa** lub w przeciwnym przypadku wywoÅ‚a funkcjÄ™ wylogowania.

```ts
import { Dispatch } from "@reduxjs/toolkit";
import { setUser } from "../../redux/reducers/userSlice";
import { userInfoRequest } from "../../client/apiRequests";
import { logoutUser } from "./logoutUser";

export async function getUserDetails(dispatch: Dispatch) {
    // API REQUEST TO GET USER INFO
    const response = await userInfoRequest();
    // IF FAILED - HANDLE LOGOUT USER
    if (response.status !== 200) return logoutUser(dispatch);
    // IF SUCCESS - SAVE DATA TO REDUX STORE
    dispatch(setUser(response.data));
    return true;
}
```


No dobra, fajnie, ale jak to wszystko ma dziaÅ‚aÄ‡? - JuÅ¼ wyjaÅ›niam:)

ZaÅ‚Ã³Å¼my, Å¼e mamy formularz logowania, flow bÄ™dzie wyglÄ…daÄ‡ nastÄ™pujÄ…co:

 1. Logujemy siÄ™ do naszego konta
 2. Odebrany token JWT zapisujemy do Cookies
 3. WywoÅ‚ujemy funkcjÄ™ **getUserDetails** - ktÃ³ra:
    1. WysyÅ‚a request do API z naszym tokenem JWT w **headers**
    2. Zapisuje pobrane dane do state'u w reduxie. - JeÅ¼eli request siÄ™ powiÃ³dÅ‚
    3. WywoÅ‚uje funkcje wylogowania - JeÅ¼eli request siÄ™ NIE powiÃ³dÅ‚

DziÄ™ki takiemu rozwiÄ…zaniu, bÄ™dziemy mieÄ‡ pewnoÅ›Ä‡, Å¼e nasz token JWT jest waÅ¼ny, bo jeÅ¼eli nie to request nie zwrÃ³ci statusu 200 i po prostu nas wyloguje.

<Image
      src="/img/persist-user/reduxFLow.png"
      alt="Grafika przedstawiajÄ…ca flow logowania, odbierajÄ…c po zalogowaniu token jwt, nastÄ™pnie wywoÅ‚ujÄ…c funkcjÄ™ ktÃ³ra pobiera dane uÅ¼ytkownika z APi, a nastÄ™pnie zapisuje te dane do Reduxa"
    />

## 3. Utrzymanie sesji uÅ¼ytkownika

Mamy juÅ¼ praktycznie wszystko, Å¼eby dokoÅ„czyÄ‡ naszÄ… logikÄ™. ZostaÅ‚o dodaÄ‡ tylko mechanizm, ktÃ³ry w przypadku wyczyszczenia stanu z naszego reduxa (np. w przypadku odÅ›wieÅ¼enia strony lub zamkniÄ™cia przeglÄ…darki), pobierze ponownie dane uÅ¼ytkownika z **API** za pomocÄ… przechowywanego **JWT**.

Do obsÅ‚ugi tego, stworzymy customowego **hooka**, zatem w folderze **/src/hooks** tworzymy plik **usePersistUser.ts**

```ts
import { useState, useEffect } from "react";
import Cookies from "js-cookie";
import { useDispatch, useSelector } from "react-redux";
import { getUser } from "../redux/reducers/userSlice";
import { getUserDetails } from "../utils/auth/getUserDetails";

const usePersistUser = () => {
  // GET USER DATA FROM REDUX STORE
  const user = useSelector(getUser);
  const dispatch = useDispatch();
  // GET JWT TOKEN STORED IN COOKIES
  const token = Cookies.get("jwt");

  // HELPER TO WAIT FOR APPLICATION RENDER BEFORE HOOK JOB FINISH
  const [loading, setLoading] = useState(true);

  // FUNCTION TO FETCH USER DETAILS 
  const handleGetUserDetails = async () => {
    await getUserDetails(dispatch);
    setLoading(false);
  }

  // USEEFFECT HOOK TO FETCH USER DETAILS WHEN DATA IN REDUX STORE IS EMPTY
  // OR SIMPLY SETLOADING TO FALSE AND RENDER APP WITHOUT TRIGGERING ANY LOGIC
  useEffect(() => {
    if (token && !user) {
      handleGetUserDetails();
    } else {
      setLoading(false);
    }
  }, []);

  return loading;
};

export default usePersistUser;
```

Jak widzicie logika jest dosyÄ‡ prosta, ale skuteczna. DziÄ™ki takiemu hookowi, bÄ™dziemy mieÄ‡ dane uÅ¼ytkownika zawsze pod rÄ™ka, a w przypadku gdy token siÄ™ przedawni zostaniemy natychmiastowo wylogowani.

Teraz wystarczy wywoÅ‚aÄ‡ owy hook, najlepiej w komponencie bezpoÅ›rednio pod tym najwyÅ¼szego poziomu (np. komponent odpowiedzialny za Routing reacta).

```ts
import { getUser } from "../redux/reducers/userSlice";
import { useSelector } from "react-redux";
import usePersistUser from "../hooks/usePersistUser";


export function Router() {
  const loading = usePersistUser();
  const user = useSelector(getUser);

  if (loading) return <>Loading...</>;

  if (!user) console.log("Nie zalogowano")

  if (user) console.log("Zalogowano");

  return (
    /// ROUTES
  );
}
```

<Image
      src="/img/persist-user/persistFlow.png"
      alt="Grafika przedstawiajÄ…ca flow utrzymywania sesji po wejÅ›ciu na stronÄ™"
    />

## Podsumowanie

Tak jak wspominaÅ‚em wczeÅ›niej, jest wiele metod na utrzymywanie sesji wczeÅ›niej zalogowanego juÅ¼ uÅ¼ytkownika. Ja przedstawiÅ‚em Wam mojÄ… wersjÄ™, wykorzystujÄ…cÄ… **Ciasteczka** oraz **Redux Toolkit**.

Metoda, ktÃ³rÄ… przedstawiÅ‚em, daje nam korzyÅ›ci takie jak:

- Sprawdzanie na bieÅ¼Ä…co waÅ¼noÅ›ci tokenu JWT
- Dane uÅ¼ytkownika dostÄ™pnÄ™ "pod rÄ™kÄ…"
- Otrzymanie informacji, czy uÅ¼ytkownik jest zalogowany przed renderem widokÃ³w

MiÅ‚ego kodzenia i do usÅ‚yszenia! âœ‹