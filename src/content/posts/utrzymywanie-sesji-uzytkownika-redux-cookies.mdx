---
title: "React - Utrzymywanie sesji uÅ¼ytkownika za pomocÄ… Redux'a i Cookies"
category: 'React'
publishedAt: '13-12-2023'
isPublished: true
popular: false
image: '/images/persist-user/thumbnail.png'
excerpt: "PrzedstawiÄ™ wam mÃ³j ulubiony sposÃ³b na podtrzymywanie sesji zalogowanego uÅ¼ytkownika w Reactcie z pomocÄ… Redux Toolkit i Cookies."
---

RobiÄ…c szybki research na pytanie: "How to persist User in React" znajdziemy wiele rozwiÄ…zaÅ„. Najpopularniejszymi metodami, ktÃ³re moÅ¼emy spotkaÄ‡ sÄ… rozwiÄ…zania korzystajÄ…ce z **localstorage**, **Cookies**, **sessionstorage** lub z zewnÄ™trznych bibliotek.

KtÃ³ra metoda bÄ™dzie najlepsza? To zaleÅ¼y:) Mi osobiÅ›cie najbardziej podpasowaÅ‚a metoda, ktÃ³rÄ… zaraz wam dokÅ‚adniej opiszÄ™ i zademonstrujÄ™ jak jÄ… zaimplementowaÄ‡.

## Co chcemy osiÄ…gnÄ…Ä‡?

Zacznijmy od rozpisania sobiÄ™, co konkretnie chcemy osiÄ…gnaÄ‡ - dziÄ™ki temu Å‚atwiej nam bÄ™dzie zobrazowaÄ‡ samÄ… implementacjÄ™.

 1. Po zalogowaniu musimy przechowaÄ‡ gdzieÅ› token - w naszym przypadku JWT.
 2. Musimy rÃ³wnieÅ¼ sprawdzaÄ‡ czy nasz token siÄ™ nie przedawniÅ‚.
 3. Po ponownym wejÅ›ciu na stronÄ™, jeÅ¼eli token jest wciÄ…Å¼ waÅ¼ny, powinniÅ›my byÄ‡ dalej zalogowani.

A teraz przejdÅºmy do konkretÃ³w ğŸ‘‡ 

## 1. Przechowywanie tokenu

Miejscem gdzie bÄ™dziemy przechowywaÄ‡ nasz token JWT bÄ™dÄ… **Cookies**. Do tego polecam bibliotekÄ™ [js-cookie](https://www.npmjs.com/package/js-cookie), dzieki ktÃ³rej w prosty sposÃ³b moÅ¼emy zapisywaÄ‡, usuwaÄ‡ i odbieraÄ‡ wartoÅ›ci z ciasteczek, dodatkowo moÅ¼emy ustawiÄ‡ na jak dÅ‚ugo majÄ… byÄ‡ waÅ¼ne.

ZaÅ‚Ã³Å¼my wiÄ™c, Å¼e wykonujemy request do logowania, jeÅ¼eli siÄ™ powiedzie moÅ¼emy zapisaÄ‡ nasz token.

```ts
import Cookies from "js-cookie";

const handleLoginRequest = async () => {
  const dataToSend = {
    email,
    password
  };
  const response = await loginService(dataToSend);
  if (response.status !== 200) return console.log("LOGIN FAILED");
  // ON LOGIN SUCCESS  
  Cookies.set("jwt", response.data.token);
};
```

JeÅ¼eli chcemy ustawiÄ‡, konkretnÄ… waÅ¼nosÄ‡ dni **ciasteczka**, moÅ¼emy to zrobiÄ‡ w taki sposÃ³b:

```ts
// TOKEN EXPIRES 7 DAYS FROM NOW
Cookies.set("jwt", response.data.token, { expires: 7 })
```

## 2. Kontrolowanie waÅ¼noÅ›ci tokenu

Mamy juÅ¼ przechowywany token, dziÄ™ki ktÃ³remu moÅ¼emy robiÄ‡ requesty. Zabierzmy siÄ™ teraz za kontrolowanie jego waÅ¼noÅ›ci.

Kluczowy do tego bÄ™dzie **request**, ktÃ³ry bÄ™dzie nam zwracaÅ‚ przykÅ‚adowo dane zalogowanego uÅ¼ytkownika.

Miejscem do przechowywania tych danych bÄ™dzie **store** w [Reduxie](https://redux-toolkit.js.org/).

StwÃ³rzmy zatem plik **store.ts** w folderze **/src/redux**.

```ts
import { configureStore } from "@reduxjs/toolkit";

export const store = configureStore({
  reducer: {},
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

A nastÄ™pnie w folderze **/src/redux/reducers** plik **userReducer.ts**

```ts
import { createSlice } from "@reduxjs/toolkit";
import { RootState } from "../store";

const initialState = {
  user: null,
};

export const userSlice = createSlice({
  initialState,
  name: "user",
  reducers: {
    // WYLOGOWANIE UÅ»YTKOWNIKA
    logout: () => initialState,
    // ZAPISANIE DANYCH UÅ»YTKOWNIKA
    setUser: (state, action) => {
      state.user = action.payload;
    },
  },
});

// POBRANIE DANYCH UÅ»YTKOWNIKA
export const getUser = (state: RootState) => state.user.user;
export const { logout, setUser } = userSlice.actions;
export default userSlice.reducer;
```

InteresujÄ… nas tutaj 3 rzeczy:

 - logout - Czyszczenie stanu uÅ¼ytkownika
 - setUser - Zapisanie danych uÅ¼ytkownika do state'u uÅ¼ytkownika.
 - getUser - Pobranie danych ze state'u uÅ¼ytkownika

Zaimportujmy teraz **userSlice** do naszego reduxowego **store**.

```ts
import { configureStore } from "@reduxjs/toolkit";
import userSlice from "./reducers/userSlice";

export const store = configureStore({
  reducer: {
    user: userSlice,
  },
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

Dodajmy teraz komponent **< Provider/>** z podpiÄ™tym **store**, aby umoÅ¼liwiÄ‡ dostÄ™p do danych Reduxa w naszej aplikacji.

Koniecznym jest, aby **< Provider/>** znalazÅ‚ siÄ™ w komponencie najwyÅ¼szego poziomu (przewaÅ¼nie bÄ™dzie to plik **main** albo **index**).

```ts
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import store from './redux/store'
import { Provider } from 'react-redux'
import { Router } from './router/Router'

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <Provider store={store}>
        <Router />
    </Provider>
  </React.StrictMode>
);

```

Potrzebujemy jeszcze funkcji, ktÃ³ra obsÅ‚uÅ¼y wyczyszczenie state'u oraz usuniÄ™cie ciasteczka z JWT. 

```ts
import { Dispatch } from "@reduxjs/toolkit";
import { logout } from "../../redux/reducers/userSlice";
import Cookies from "js-cookie";

export function logoutUser(dispatch: Dispatch) {
  Cookies.remove("jwt");
  dispatch(logout());
  window.location.href = "/login";
}
```
A takÅ¼e funkcji, ktÃ³ra wyÅ›le request do API z zapisanym tokenem JWT i w przypadku powodzenia zapisze dane do **reduxa** lub w przeciwnym przypadku wywoÅ‚a funkcjÄ™ wylogowania.

```ts
import { Dispatch } from "@reduxjs/toolkit";
import { setUser } from "../../redux/reducers/userSlice";
import { userInfoRequest } from "../../client/apiRequests";
import { logoutUser } from "./logoutUser";

export async function getUserDetails(dispatch: Dispatch) {
    // API REQUEST TO GET USER INFO
    const response = await userInfoRequest();
    // IF FAILED - HANDLE LOGOUT USER
    if (response.status !== 200) return logoutUser(dispatch);
    // IF SUCCESS - SAVE DATA TO REDUX STORE
    dispatch(setUser(response.data));
    return true;
}
```


No dobra, fajnie, ale jak to wszystko ma dziaÅ‚aÄ‡? - JuÅ¼ wyjaÅ›niam:)

ZaÅ‚Ã³Å¼my, Å¼e mamy formularz logowania, flow bÄ™dzie wyglÄ…daÄ‡ nastÄ™pujÄ…co:

 1. Logujemy siÄ™ do naszego konta
 2. Odebrany token JWT zapisujemy do Cookies
 3. WywoÅ‚ujemy funkcjÄ™ **getUserDetails** - ktÃ³ra:
    1. WysyÅ‚a request do API z naszym tokenem JWT w **headers**
    2. Zapisuje pobrane dane do state'u w reduxie. - JeÅ¼eli request siÄ™ powiÃ³dÅ‚
    3. WywoÅ‚uje funkcje wylogowania - JeÅ¼eli request siÄ™ NIE powiÃ³dÅ‚

DziÄ™ki takiemu rozwiÄ…zaniu, bÄ™dziemy mieÄ‡ pewnoÅ›Ä‡, Å¼e nasz token JWT jest waÅ¼ny, bo jeÅ¼eli nie to request nie zwrÃ³ci statusu 200 i po prostu nas wyloguje.

<Image
      src="/images/persist-user/reduxFLow.png"
      alt="Grafika przedstawiajÄ…ca flow logowania, odbierajÄ…c po zalogowaniu token jwt, nastÄ™pnie wywoÅ‚ujÄ…c funkcjÄ™ ktÃ³ra pobiera dane uÅ¼ytkownika z APi, a nastÄ™pnie zapisuje te dane do Reduxa"
    />

## 3. Utrzymanie sesji uÅ¼ytkownika

Mamy juÅ¼ praktycznie wszystko, Å¼eby dokoÅ„czyÄ‡ naszÄ… logikÄ™. ZostaÅ‚o dodaÄ‡ tylko mechanizm, ktÃ³ry w przypadku wyczyszczenia stanu z naszego reduxa (np. w przypadku odÅ›wieÅ¼enia strony lub zamkniÄ™cia przeglÄ…darki), pobierze ponownie dane uÅ¼ytkownika z **API** za pomocÄ… przechowywanego **JWT**.

Do obsÅ‚ugi tego, stworzymy customowego **hooka**, zatem w folderze **/src/hooks** tworzymy plik **usePersistUser.ts**

```ts
import { useState, useEffect } from "react";
import Cookies from "js-cookie";
import { useDispatch, useSelector } from "react-redux";
import { getUser } from "../redux/reducers/userSlice";
import { getUserDetails } from "../utils/auth/getUserDetails";

const usePersistUser = () => {
  // GET USER DATA FROM REDUX STORE
  const user = useSelector(getUser);
  const dispatch = useDispatch();
  // GET JWT TOKEN STORED IN COOKIES
  const token = Cookies.get("jwt");

  // HELPER TO WAIT FOR APPLICATION RENDER BEFORE HOOK JOB FINISH
  const [loading, setLoading] = useState(true);

  // FUNCTION TO FETCH USER DETAILS 
  const handleGetUserDetails = async () => {
    await getUserDetails(dispatch);
    setLoading(false);
  }

  // USEEFFECT HOOK TO FETCH USER DETAILS WHEN DATA IN REDUX STORE IS EMPTY
  // OR SIMPLY SETLOADING TO FALSE AND RENDER APP WITHOUT TRIGGERING ANY LOGIC
  useEffect(() => {
    if (token && !user) {
      handleGetUserDetails();
    } else {
      setLoading(false);
    }
  }, []);

  return loading;
};

export default usePersistUser;
```

Jak widzicie logika jest dosyÄ‡ prosta, ale skuteczna. DziÄ™ki takiemu hookowi, bÄ™dziemy mieÄ‡ dane uÅ¼ytkownika zawsze pod rÄ™ka, a w przypadku gdy token siÄ™ przedawni zostaniemy natychmiastowo wylogowani.

Teraz wystarczy wywoÅ‚aÄ‡ owy hook, najlepiej w komponencie bezpoÅ›rednio pod tym najwyÅ¼szego poziomu (np. komponent odpowiedzialny za Routing reacta).

```ts
import { getUser } from "../redux/reducers/userSlice";
import { useSelector } from "react-redux";
import usePersistUser from "../hooks/usePersistUser";


export function Router() {
  const loading = usePersistUser();
  const user = useSelector(getUser);

  if (loading) return <>Loading...</>;

  if (!user) console.log("Nie zalogowano")

  if (user) console.log("Zalogowano");

  return (
    /// ROUTES
  );
}
```

<Image
      src="/images/persist-user/persistFlow.png"
      alt="Grafika przedstawiajÄ…ca flow utrzymywania sesji po wejÅ›ciu na stronÄ™"
    />

## Podsumowanie

Tak jak wspominaÅ‚em wczeÅ›niej, jest wiele metod na utrzymywanie sesji wczeÅ›niej zalogowanego juÅ¼ uÅ¼ytkownika. Ja przedstawiÅ‚em Wam mojÄ… wersjÄ™, wykorzystujÄ…cÄ… **Ciasteczka** oraz **Redux Toolkit**.

Metoda, ktÃ³rÄ… przedstawiÅ‚em, daje nam korzyÅ›ci takie jak:

- Sprawdzanie na bieÅ¼Ä…co waÅ¼noÅ›ci tokenu JWT
- Dane uÅ¼ytkownika dostÄ™pnÄ™ "pod rÄ™kÄ…"
- Otrzymanie informacji, czy uÅ¼ytkownik jest zalogowany przed renderem widokÃ³w

MiÅ‚ego kodzenia i do usÅ‚yszenia! âœ‹